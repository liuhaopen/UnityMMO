// Generated by IJobProcessComponentDataGenerator.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#if !UNITY_ZEROPLAYER

using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using Unity.Jobs.LowLevel.Unsafe;
using System.Runtime.InteropServices;
using UnityEngine.Scripting;
using System;


namespace Unity.Entities
{
    


        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_D<,>))]
        public interface IJobProcessComponentData<U0> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_D
            where U0 : struct, IComponentData
        {
            void Execute(ref U0 c0);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_ED<,>))]
        public interface IJobProcessComponentDataWithEntity<U0> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_ED
            where U0 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DD<,,>))]
        public interface IJobProcessComponentData<U0, U1> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDD<,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDD<,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDD<,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDD<,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDD<,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDDD<,,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3, U4> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDDD<,,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_DDDDDD<,,,,,,>))]
        public interface IJobProcessComponentData<U0, U1, U2, U3, U4, U5> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_DDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            void Execute(ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
        }

        [JobProducerType(typeof(JobProcessComponentDataExtensions.JobStruct_Process_EDDDDDD<,,,,,,>))]
        public interface IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4, U5> : JobProcessComponentDataExtensions.IBaseJobProcessComponentData_EDDDDDD
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
        {
            void Execute(Entity entity, int index, ref U0 c0, ref U1 c1, ref U2 c2, ref U3 c3, ref U4 c4, ref U5 c5);
        }

    public static partial class JobProcessComponentDataExtensions
    {
            
            public static JobHandle Schedule<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, 1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleSingle<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle Run<T>(this T jobData, ComponentSystemBase system, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, system, null, -1, dependsOn, ScheduleMode.Run);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleGroup<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle ScheduleGroupSingle<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Batched);             
                throw new System.ArgumentException("Not supported");
            }
            
            public static JobHandle RunGroup<T>(this T jobData, ComponentGroup componentGroup, JobHandle dependsOn = default(JobHandle))
                where T : struct, IBaseJobProcessComponentData
            {
                var typeT = typeof(T);             
                if (typeof(IBaseJobProcessComponentData_D).IsAssignableFrom(typeT))
                    return ScheduleInternal_D(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_ED).IsAssignableFrom(typeT))
                    return ScheduleInternal_ED(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_DDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_DDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                if (typeof(IBaseJobProcessComponentData_EDDDDDD).IsAssignableFrom(typeT))
                    return ScheduleInternal_EDDDDDD(ref jobData, null, componentGroup, 1, dependsOn, ScheduleMode.Run);             
                throw new System.ArgumentException("Not supported");
            }
            
            internal static unsafe JobHandle ScheduleInternal_D<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_D<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_D<,>), isParallelFor, ref JobStruct_ProcessInfer_D<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_D<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_D : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_D<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_D<T, U0>
                where T : struct, IJobProcessComponentData<U0>
            where U0 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_D<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_D<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_D<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_D<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_ED<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_ED<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_ED<,>), isParallelFor, ref JobStruct_ProcessInfer_ED<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_ED<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_ED : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_ED<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_ED<T, U0>
                where T : struct, IJobProcessComponentDataWithEntity<U0>
            where U0 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_ED<T, U0>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_ED<T, U0> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_ED<T, U0> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_ED<T, U0> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DD<,,>), isParallelFor, ref JobStruct_ProcessInfer_DD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_DD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DD<T, U0, U1>
                where T : struct, IJobProcessComponentData<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDD<,,>), isParallelFor, ref JobStruct_ProcessInfer_EDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_EDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDD<T, U0, U1>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDD<T, U0, U1>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDD<T, U0, U1> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDD<T, U0, U1> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_DDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDD<T, U0, U1, U2>
                where T : struct, IJobProcessComponentData<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDD<,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_EDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDD<T, U0, U1, U2>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDD<T, U0, U1, U2>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDD<T, U0, U1, U2> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDD<T, U0, U1, U2> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_DDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDD<T, U0, U1, U2, U3>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDD<,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_EDDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDD<T, U0, U1, U2, U3>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDD<T, U0, U1, U2, U3>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDD<T, U0, U1, U2, U3> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_DDDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly4 == 0, jobData.Iterator.IndexInGroup4));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDDD<,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_EDDDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDD<T, U0, U1, U2, U3, U4> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly4 == 0, jobData.Iterator.IndexInGroup4));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_DDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_DDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_DDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_DDDDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_DDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_DDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>
                where T : struct, IJobProcessComponentData<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_DDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly4 == 0, jobData.Iterator.IndexInGroup4));
                        var ptr5 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly5 == 0, jobData.Iterator.IndexInGroup5));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                        }
                    }
                }
            }
            
            internal static unsafe JobHandle ScheduleInternal_EDDDDDD<T>(ref T jobData, ComponentSystemBase system, ComponentGroup componentGroup, int innerloopBatchCount, JobHandle dependsOn, ScheduleMode mode)
                where T : struct
            {
                JobStruct_ProcessInfer_EDDDDDD<T> fullData;
                fullData.Data = jobData;

                var isParallelFor = innerloopBatchCount != -1;
                Initialize(system, componentGroup, typeof(T), typeof(JobStruct_Process_EDDDDDD<,,,,,,>), isParallelFor, ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, out fullData.Iterator);
                return Schedule(UnsafeUtility.AddressOf(ref fullData), fullData.Iterator.m_Length, innerloopBatchCount, isParallelFor, ref JobStruct_ProcessInfer_EDDDDDD<T>.Cache, dependsOn, mode);
            }


            [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)]
            public interface IBaseJobProcessComponentData_EDDDDDD : IBaseJobProcessComponentData { }

            [StructLayout(LayoutKind.Sequential)]
            private struct JobStruct_ProcessInfer_EDDDDDD<T> where T : struct
            {
                public static JobProcessComponentDataCache Cache;
    
                public ProcessIterationData Iterator;
                public T Data;
            }
    
            [StructLayout(LayoutKind.Sequential)]
            internal struct JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>
                where T : struct, IJobProcessComponentDataWithEntity<U0, U1, U2, U3, U4, U5>
            where U0 : struct, IComponentData
            where U1 : struct, IComponentData
            where U2 : struct, IComponentData
            where U3 : struct, IComponentData
            where U4 : struct, IComponentData
            where U5 : struct, IComponentData
            {
                public ProcessIterationData Iterator;
                public T Data;
    
                [Preserve]
                public static IntPtr Initialize(JobType jobType)
                {
                    return JobsUtility.CreateJobReflectionData(typeof(JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5>), typeof(T), jobType, (ExecuteJobFunction) Execute);
                }
    
                delegate void ExecuteJobFunction(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> data, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex);

                public static unsafe void Execute(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr additionalPtr, IntPtr bufferRangePatchData, ref JobRanges ranges, int jobIndex)
                {
                    if (jobData.Iterator.m_IsParallelFor)
                    {
                        int begin, end;
                        while (JobsUtility.GetWorkStealingRange(ref ranges, jobIndex, out begin, out end))
                            ExecuteChunk(ref jobData, bufferRangePatchData, begin, end);
                    }
                    else
                    {
                        ExecuteChunk(ref jobData, bufferRangePatchData, 0, jobData.Iterator.m_Length);
                    }
                }

                static unsafe void ExecuteChunk(ref JobStruct_Process_EDDDDDD<T, U0, U1, U2, U3, U4, U5> jobData, IntPtr bufferRangePatchData, int begin, int end)
                {
                    ref ComponentChunkIterator chunkIterator = ref jobData.Iterator.Iterator;
    
                    for (var blockIndex = begin; blockIndex != end; ++blockIndex)
                    {
                        jobData.Iterator.Iterator.MoveToChunkWithoutFiltering(blockIndex);
    
                        var processBlock = jobData.Iterator.Iterator.MatchesFilter();
    
                        if (!processBlock)
                            continue;
    
                        int beginIndex, endIndex;
                        chunkIterator.GetCurrentChunkRange(out beginIndex, out endIndex);
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
                        JobsUtility.PatchBufferMinMaxRanges(bufferRangePatchData, UnsafeUtility.AddressOf(ref jobData), beginIndex, endIndex - beginIndex);
    #endif
    
                        var count = chunkIterator.GetCurrentChunkCount();
    
                        var ptrE = (Entity*)UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(false, 0));
                        var ptr0 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly0 == 0, jobData.Iterator.IndexInGroup0));
                        var ptr1 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly1 == 0, jobData.Iterator.IndexInGroup1));
                        var ptr2 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly2 == 0, jobData.Iterator.IndexInGroup2));
                        var ptr3 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly3 == 0, jobData.Iterator.IndexInGroup3));
                        var ptr4 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly4 == 0, jobData.Iterator.IndexInGroup4));
                        var ptr5 = UnsafeUtilityEx.RestrictNoAlias(chunkIterator.GetCurrentChunkComponentDataPtr(jobData.Iterator.IsReadOnly5 == 0, jobData.Iterator.IndexInGroup5));

    
                        for (var i = 0; i != count; i++)
                        {
                            jobData.Data.Execute(ptrE[i], i + beginIndex, ref UnsafeUtilityEx.ArrayElementAsRef<U0>(ptr0, i), ref UnsafeUtilityEx.ArrayElementAsRef<U1>(ptr1, i), ref UnsafeUtilityEx.ArrayElementAsRef<U2>(ptr2, i), ref UnsafeUtilityEx.ArrayElementAsRef<U3>(ptr3, i), ref UnsafeUtilityEx.ArrayElementAsRef<U4>(ptr4, i), ref UnsafeUtilityEx.ArrayElementAsRef<U5>(ptr5, i));
                        }
                    }
                }
            }
        
    }
}

#endif
